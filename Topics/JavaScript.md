# JavaScript  

### Execution Context (실행문맥) 에 대해 설명해주세요.
- 실행 컨텍스트란, 실행가능한 코드가 실행되는 환경, 실행 되기 위해 필요한 환경이라고 할 수 있다.
- 물리적으로는 변수 객체, 스코프 체인, this 프로퍼티 속성으로 이루어져 있다.
- 변수객체 : 코드들이 실행될 때 필요한 정보들을 담아두는 곳이다.
- 스코프체인 : 연결리스트 형태로 현재 실행중인 컨텍스트의 유효한 범위를 나타낸 것이다.
- this 프로퍼티 : this가 가리키는 객체를 저장한다.
- 종류로는 전역 컨텍스트와 함수 컨텍스트가 있다.
    - 전역 컨텍스트 : 함수 안에서 실행되는 코드가 아닌 모든 스크립트는 전역 컨텍스트에서 실행된다.
    - 함수 컨텍스트 : 함수가 호출 될 때를 기점으로 생성되고 함수의 동작이 모두 종료되면, 소멸된다.
- 이러한 속성들을 기반으로 실행컨텍스트 내부에서  코드가 실행된다.

### var, let, const 차이점에 대해 설명해 주세요. 
- var : 선언과 초기화가 함께 이루어 진다.
     -> 초기화 이전에 접근하면 undefined - 함수레벨 스코프
- let : 스코프 최상단에 선언 되지만, 초기화는 선언문에 도달했을때 실행된다.
     -> 초기화 이전에 접근하면 ReferenceError (TDZ 일시적 사각지대에 놓이게 된다)
- const : 블록범위의 상수를 선언하고, 상수의 값은 재할당 할 수 없으며, 다시 선언할 수도 없다.
     -> 선언시 TDZ 일시적사각지대에 놓인다.

### this 에 대해 설명해 주세요.
- 호출 시점에 실행 함수가 가리키는 객체이다.
- 4가지 패턴이 있다. 일반함수 실행, 메서드 실행, 생성자(new) 실행, 명시적 실행(call, apply, bind)이 있다. 


### IIFE(즉시실행함수)에 대해 설명해주세요. 
- 최초 한번 선언 동시와 함께 실행되는 함수<br>
- 라이브러리 간 변수명 충돌 예방 (함수/ 변수 SCOPE)<br>
- 예시로, jQuery 경우 IIFE로 선언되어 같은 변수명을 사용해도 오염되지 않음.

### 호이스팅 정의에 대해 설명해주세요. 
- 선언부분이 최상단으로 끌어올려지는(hoist) 현상<br>
- 함수 선언이 실행하는 부분보다 뒤에 있더라도 함수선언을 ‘끌어오리는 것(hoist)’이다.<br>
- 자바스크립트 변수 생성과 초기화 작업이 분리되어 진행되므로 가능하다.

### SSR vs CSR 
- <em>Server Side Rendering (서버에서 렌더링)</em><br>
     - 코드 다운로드 기다리지 않고 서버에서 보여진 HTML 미리 준비해 클라이언트에게 응답 (속도가 빠르다.)<br>
     - 요청 시마다 서버에서 처리하여 새로고침으로 응답<br>
     - 각 페이지마다 고유의 URL이 존재하므로 history 관리 및 검색엔진최적화(SEO)에 유리하다.<br>
- <em>Client Side Rendering (클라이언트 렌더링)</em><br>
     - 최초에 한번 전체 페이지 로딩이후 요청 올 때마다 클라이언트가 해석하고 렌더링한다.<br>
     - URL을 변경시키지 않으므로 history 관리가 동작하지 않기 때문에 SEO 이슈가 있다.

### 클로저 정의
- 생명주기가 끝난 외부 함수의 변수를 참조하는 함수
- 실행 원리: 외부함수 컨텍스트 소멸해도 SC 참조하므로 AO는 소멸하지 않으므로 참조 가능
- 장점: 비공개변수 생성 가능 (은닉), 전역변수 대체용
- 단점: 메모리 낭비, 유지보수 어려움

### 쿠키 vs 캐시 차이점
- 서버가 사용자에게 빠른 정보 제공 (http 프로토콜의 Connectionless, Stateless 특징 고려)
- 쿠키 🍪
     - 특정사이트 접속할 때 생성되는 정보를 담아두는 임시파일 (4kb)
     - 서버가 전송하여 클라이언트의 상태를 PC(하드디스크)에 저장하는 작은 기록 정보 파일
	- 만료기간이 있어 시간이 지나면 자동 삭제됨
	- ex.인증 정보, 다시보지않기 등 활용
- 캐시 💰
     - 이전에 호출한 웹 페이지 요소를 자동으로 복사해 저장하는 임시저장소
     - 첫 요청 시 파일을 내려받아 특정 위치(내부 디스크) 에 복사본을 저장하여 서버 지연을 줄임
     - 웹 페이지가 빠르게 렌더링
     - 사용자가 직접 수동으로 삭제됨

### 객체 프로토타입 정의
- 모든 객체는 자신의 부모 역할을 하는 Prototype 객체를 가리키는 숨겨진 참조링크(__proto__) 가짐!
- __proto__ : (인터널 슬롯) 자신의 부모 Prototype 객체를 가리킴.
- Prototype 객체: constructor 속성 하나만 가지는 객체로, 같은 생성자로부터 만들어진 인스턴스들이 바라봄.
- 예시로 hasOwnProperty를 사용할 수 있는 이유는 Object 부모의 메서드를 Prototype chaining을 통해 가능함!

### 자바스크립트 비동기 처리에 대해서
- 비동기란 요청을 보낸 후 응답과 관계없이 다음 동작을 실행할 수 있는 방식이다.
- 자바스크립트는 Single Thread 이다. 그렇기 때문에 이벤트 루프에 기반하여 비동기 처리를 할 수 있다.
- 브라우저에서 제공하는 WebAPIs, Event Table, Callback Queue, EventLoop 등으로 구성 되어있다.
- 즉시 처리 하지 못하는 이벤트들을 WebAPIs를 이용하여 이벤트의 콜백을 콜백큐로 보낸다.
- 이벤트루프를 통해 콜스택이 비었을 경우 실행한다.
- 비동기 처리를 위해 Promise, Async Await 를 사용 할 수 있다.

### `AMD`와 `CommonJS`는 무엇이고, 이것들에 대해 어떻게 생각하시나요?
- JS 파일간의 의존성을 어떻게 갖게 할지 정하는 것이다. 일반적으로 client(브라우저)에서는 AMD 가 server에서는 commonJS가 적합하지만, 두 스펙 모두 server, client 환경에서 사용이 가능하다. es6는 브라우저 단에서 사용이 가능하나, 호환성 문제로 바벨을 통한 컴파일링이 필요하다.
- 자바스크립트의 모듈 시스템이 기존에는 HTML에서 <script> 태그를 이용하여 js파일들을 불러왔다. 서로 다른 파일임에도 불구하고 서로가 의존적이며, 파일 로드하는 순서가 중요했었다. 

 이러한 점을 보완하기 위해 등장한것이 모듈 시스템이다. 외부에서 사용할 수 있게 특정 함수나 오브젝트 등을 모듈화 하고, 해당 모듈을 사용하려는 쪽에서는 필요한 모듈만 불러와서 사용하면 된다. 

 모듈을 정의하기 위한 문법에는 여러가지가 있다. AMD, CommonJS, ES6등이 있다.
-  **CommonJS**
: javascript 를 브라우저 뿐만 아니라 **서버사이드** 애플리케이션이나 **데스크톱** 애플리케이션에서도 사용하려고 조직한 자발적 워킹 그룹이다. `Common` 은 Javascript를 브라우저 에서만 사용하는 것이 아니라 일반적인 범용 언어로 사용할 수 있도록 하겠다는 의지를 나타내고 있는 것이다.  (Node.js, curl.js 등)
	- 내보내기(정의) : `export` , `module.exports`
        - 가져오기(사용) : `require` , `require.define() (서버 모듈을 브라우저에서 비동기적으로 사용)`
        - CommonJS 모듈화는 세부분으로 이루어진다.
            - 스코프(Scope) : 모든 모듈은 자신만의 독립적인 실행영역이 있어야한다.
            - 정의(Definition) : 모듈 정의는 exports 객체를 이용한다.
            - 사용(Usage) : 모듈 사용은 require 함수를 이용한다.

- **AMD** (Asynchronus Module Definition)
: 비동기 상황에도 JavaScript 모듈을 쓰기 위해 CommonJS에서 논의 하다가 합의점을 이루지 못하고 독립한 그룹. 브라우저 내에서의 실행에 중점을 둠 (Require JS,, curlJS 등)
    - 필요한 파일이 모두 로컬 디스크에 있어 바로 볼 수 있는 상황 (서버사이드) 에서는 CommonJS 명세가 AMD 보다 더 간결 하다. 반면 필요한 파일을 네트워크 통해서 받아야 하는 경우 AMD 가 더 유연한 환경을 제공한다.
    - javascript 는 파일 스코프가 따로 존재하지 않기 때문에 define() 함수 로 파일 스코프의 역할을 대신한다.

- **ES6**
: 브라우저 호환성 문제로 일반적으로 babel을 통해 commonJS 로 컴파일 한다.
    - reference :[https://d2.naver.com/helloworld/12864](https://d2.naver.com/helloworld/12864) 
    [https://velog.io/@ckdgus2246/프론트엔드-면접-질문-정리-JS-2-CommonJS-AMD](https://velog.io/@ckdgus2246/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC-JS-2-CommonJS-AMD)
    
### (함수 선언방식) 다음 코드의 차이점은?
```jsx
function Person(){} // 함수 선언식 - Function Declarations
var person = Person() //함수 표현식 - Function Expressions
var person = new Person() //함수 생성자 
```

- 함수 선언식 : 함수를 선언하고 함수 이름을 호출하는 방법
- 함수 표현식 : 함수를 변수에 저장하고, 변수를 통해 함수를 사용하는 방법
- 함수 생성자 :  기본 내장 생성자 함수로 부터 생성된 객체이다. 생성자 함수로 생성한 객체들이 프로퍼티와 메서드를 공유하기 위해 prototype 을 이용 할 수 있다.
    - new Function(arg1, arg2, ... argN, functionBody)
- 함수 선언식과 함수 표현식의 차이점은 **호이스팅**이다.
    - 함수 선언으로 생성된 함수는 함수가 정의 되기 전에 실행이 가능하며, 함수 표현식은 그렇지 않다.

### CORS 에 대해 설명하고 대처방안은 어떻게 되는가?
: ‘교차 출처 자원 공유’
웹 브라우저에서 외부 도메인 서버와 통신하기 위한 방식을 표준화한 스펙

자원이 자신의 출처(도메인, 프로토콜, 포트)와 다를때,
HTTP 헤더를 사용하여 다른 출처의 선택한 자원에 접근 가능 권한을 부여하도록 브라우저에 알려주는 체제

ex) access-control-allow-origin(서버와 클라이언트가 정해진 헤더를 통해), proxy server

* Same Origin Policy (동일 출처 정책)
사용자의 입력을 캐내어 다른 페이지로 흘려보내는 것을 막기 위한 보안정책
웹페이지의 스크립트는 그 페이지와 같은 서버에 있는 주소로만 ajax 요청 가능

preflight request (사전요청)
: 실제로 요청하려는 경로와 같은 url에 대해 OPTIONS 메소드로 요청을 통해 권한이 있는지 확인

- 참조: https://brunch.co.kr/@adrenalinee31/1

### immutable vs mutable
: 메모리영역에서 변경 가능 여부를 의미

- immutable :: 변경불가능 [ 원시 타입 ]
: 값을 새로 할당할 경우 새로 메모리 생성하여 가리킴

- mutable :: 변경가능 [ 참조 타입 ]
: 주소로 바라보고 있는 메모리 영역 값이 바뀜
ex) custom function, copy, assign

### Arrow 함수에 대해 설명해주세요.
- es6에서 사용가능한 함수, 익명 함수로만 사용

- 일반함수 vs 화살표함수: this 바인딩 객체가 다름
	일반함수는 함수를 호출할 때 어떻게 호출되었는지에 따라 동적으로 결정
	화살표함수는 함수를 선언할 때 반잉딩할 개체 정적으로 결정 (lexical scope)

- 참조: https://poiemaweb.com/es6-arrow-function

